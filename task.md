# ТЗ: Семейный ИИ-планировщик на Agno

## 1. Общее описание
**Цель:** Создать ИИ-ассистента (бота) для координации семейных дел, согласования расписания и автоматического планирования через мессенджер (Telegram).

**Ключевая ценность:** "Невидимый семейный помощник", который берёт на себя рутину планирования, но **НЕ превращает дом в JIRA**. Меньше "а ты не забыла?", меньше конфликтов "почему ты не сказала?", больше спокойствия.

**Ключевые принципы:**
*   **Framework-agnostic:** Бизнес-логика (тулы) должна быть изолирована в чистых Python-функциях для максимальной переносимости между фреймворками.
*   **Self-hosted/Бесплатно:** Развертывание на собственном сервере или бесплатном cloud-хостинге.
*   **Прототипирование для CTO:** Код должен быть понятным, модульным и быстро адаптируемым для проверки гипотез.
*   **Естественный язык:** Пользователи пишут планы нативным языком ("в субботу в 10 секция у сына"), бот разбирает и структурирует.
*   **Тон общения:** Спокойный, разговорный, без менеджерских терминов. НЕ "Задача создана. Статус: proposed. ID: 123", а "Запомнил: секция сына, суббота 10:00."

## 2. Архитектурные требования

### 2.1. Фреймворк и структура
*   **Основной фреймворк:** Agno.
*   **Язык:** Python 3.11+.
*   **Архитектура:** Модульная. Чистая бизнес-логика отделена от оберток фреймворка.
*   **Стиль:** Асинхронный (использование `async/await`).
*   **LLM модель:** DeepSeek 

### 2.2. Модель взаимодействия
*   **Один бот** → **два личных чата** (муж↔бот, жена↔бот).
*   Каждый пользователь общается с ботом в своем личном чате.
*   Бот автоматически уведомляет партнера о новых планах (см. раздел 3.3).

### 2.3. Данные и состояние
*   **Хранение расписания:** Использовать **SQLite базу данных** для хранения событий, пользователей и истории диалогов агента. Agno использует `SqliteDb` с таблицей сессий для истории, наши таблицы (users, events, event_participants) хранят данные календаря.
*   **Структуры данных:** Все входные/выходные данные тулов и сообщения описывать через **Pydantic-модели** (например, `CalendarEvent`, `User`, `TimeSlot`).
*   **Память агента:** Включить долгосрочную память (`add_history_to_context=True`) для сохранения контекста диалога.
*   **Часовой пояс:** Всегда используется `Europe/Moscow` для всех операций с датой и временем.

### 2.4. Структура базы данных (SQLite)

**Примечание:** База данных создается автоматически при первом запуске. Схема определяется через SQLAlchemy или прямые SQL-запросы.

**Таблица: `events`**
| Поле | Тип | Описание |
|------|-----|----------|
| `id` | INTEGER PRIMARY KEY | Уникальный ID события |
| `title` | TEXT | Заголовок события ("секция у сына") |
| `datetime` | DATETIME | Дата и время события (UTC, хранить с timezone) |
| `duration_minutes` | INTEGER | Продолжительность в минутах |
| `creator_telegram_id` | INTEGER | Telegram ID создателя |
| `status` | TEXT | "предложено" / "подтверждено" (enum) |
| `category` | TEXT | "дети" / "дом" / "ремонт" / "личное" (enum) |
| `created_at` | DATETIME | Время создания записи |
| `partner_notified` | BOOLEAN | Флаг уведомления партнера (default: False) |

**Таблица: `users`**
| Поле | Тип | Описание |
|------|-----|----------|
| `id` | INTEGER PRIMARY KEY | Уникальный ID пользователя |
| `telegram_id` | INTEGER UNIQUE | Telegram ID пользователя |
| `name` | TEXT | Имя для обращения |
| `partner_telegram_id` | INTEGER | Telegram ID партнера (nullable) |
| `digest_time` | TEXT | Время отправки утреннего дайджеста (формат "HH:MM", default: "07:00") |

**Таблица: `event_participants`** (для событий с несколькими участниками)
| Поле | Тип | Описание |
|------|-----|----------|
| `id` | INTEGER PRIMARY KEY | Уникальный ID связи |
| `event_id` | INTEGER | FK к events.id |
| `user_id` | INTEGER | FK к users.id |
| `created_at` | DATETIME | Время создания связи |

**Индексы:**
*   `events(datetime, creator_telegram_id)` - для быстрого поиска по дате и пользователю
*   `users(telegram_id)` - для быстрого поиска пользователя
*   `event_participants(event_id, user_id)` - для поиска участников события

## 3. Функциональные требования (Тулы / Инструменты)
Каждый тул — это асинхронная Python-функция с аннотацией типов.

### 3.1. Основные инструменты

1.  **`check_availability`**
    *   **Вход:** `user_id: int`, `start_time: datetime`, `duration_minutes: int`
    *   **Выход:** `AvailabilityResult` (Pydantic модель: `is_available: bool`, `conflicting_events: List[CalendarEvent]`)
    *   **Логика:** Проверяет в БД наличие событий у пользователя на заданный слот. Возвращает список конфликтующих событий если есть.

2.  **`schedule_event`**
    *   **Вход:** `event: CalendarEvent` (Pydantic модель), `creator_telegram_id: int`, `notify_partner: bool = True`
    *   **Выход:** `ScheduleResult` (Pydantic модель: `success: bool`, `event_id: int`, `conflicts: List[ConflictInfo]`, `message: str`)
    *   **Логика:**
        *   **Автоматически определяет участников:** Находит партнера создателя по `users.partner_telegram_id` и добавляет обоих партнеров в `user_ids` (семейный календарь по умолчанию).
        *   Проверяет доступность через `check_availability` (общий календарь).
        *   Если свободно — создает запись о событии в БД.
        *   Если есть конфликт:
            *   **НЕ создает событие**, возвращает информацию о конфликте.
            *   **Важно:** Бот **НЕ решает конфликты автоматически**, только подсвечивает их. Пользователь сам решает что делать (перенести, отменить или оставить конфликт).
        *   Если `notify_partner=True` и событие создано успешно — вызывает `notify_partner_about_event`.

3.  **`get_today_agenda`** (для утренних дайджестов)
    *   **Вход:** `user_ids: List[int]`, `date: Optional[date] = None` (default: сегодня)
    *   **Выход:** `List[CalendarEvent]`
    *   **Логика:** Возвращает список запланированных событий на указанную дату для группы пользователей, отсортированный по времени.

4.  **`notify_partner_about_event`** (КРИТИЧНО для MVP)
    *   **Вход:** `event: CalendarEvent`, `creator_telegram_id: int`
    *   **Выход:** `bool` (успешно отправлено/нет)
    *   **Логика:**
        *   Находит партнера создателя по `users.partner_telegram_id`.
        *   Формирует сообщение в спокойном тоне: "Жена заняла субботу 10:00: секция у сына" или "Муж занял субботу 11:00: поехать за продуктами".
        *   Отправляет сообщение партнеру через Telegram API (не через агента, чтобы избежать рекурсии).
        *   Устанавливает флаг `partner_notified=True` в БД.

### 3.2. Автоматические задачи (фоновые)

1.  **Утренний дайджест** (КРИТИЧНО для MVP)
    *   **Триггер:** Ежедневно для каждого пользователя в его настраиваемое время (`users.digest_time`, по умолчанию 07:00) через `schedule` или cron.
    *   **Логика:**
        *   Для каждого пользователя с настроенным `digest_time` вызывает `get_today_agenda` с его `telegram_id` и `partner_telegram_id`.
        *   Формирует сообщение в спокойном тоне (см. примеры ниже).
        *   Отправляет одинаковый дайджест обоим партнерам (если у них разное время дайджеста, каждый получит в свое время).
    *   **Примеры сообщений:**
        *   Спокойный день: "Доброе утро! Сегодня спокойный день:\n- 10:00 — секция у сына\n- 11:00 — поехать за продуктами"
        *   Насыщенный день: "Доброе утро! Сегодня много дел:\n- 09:00 — уборка\n- 10:00 — секция у сына\n- 12:00 — обед с родителями"
        *   Свободный день: "Доброе утро! На сегодня планов нет. Отдыхайте!"

### 3.3. Интеграция с мессенджером
*   **Канал:** Telegram.
*   **Реализация:** Отдельный модуль (`telegram_bot.py`), который:
    *   Запускает бота через `python-telegram-bot` или `aiogram`.
    *   Принимает сообщения в личных чатах.
    *   Передает сообщение агенту `family_planner.run()` для обработки.
    *   Отправляет ответ пользователю.
    *   **Важно:** Обрабатывает команды типа "что у нас сегодня?" → вызывает `get_today_agenda` и форматирует ответ.

## 4. Агент и его конфигурация

### 4.1. Конфигурация агента
```python
# Конфигурация агента в main.py
from agno.db.sqlite import SqliteDb

# Используем SQLite базу данных
DB_FILE = os.getenv("DB_FILE", "family_calendar.db")

family_planner = Agent(
    name="Family Planner",
    model=DeepSeek(id="deepseek-chat", api_key=os.getenv("DEEPSEEK_API_KEY"), base_url="https://api.deepseek.com"), # DeepSeek модель
    instructions="""Ты вежливый координатор для семьи. Твоя задача — помогать планировать дела, находить пересечения в расписаниях и разрешать конфликты.

КЛЮЧЕВЫЕ ПРИНЦИПЫ:
1. Говори спокойно, разговорно, без менеджерских терминов. НЕ используй слова "задача", "статус", "ID", "дедлайн".
2. Понимай планы пользователя из естественного языка напрямую и вызывай schedule_event с нужными параметрами (title, datetime, category, duration_minutes).
3. Если что-то непонятно в сообщении пользователя - спроси уточняющие вопросы (например: "Во сколько примерно продлится секция?" или "Не понял дату, уточни пожалуйста").
4. Все события автоматически добавляются в общий семейный календарь (оба партнера участвуют).
5. Всегда используй инструменты для проверки календаря перед планированием.
6. При конфликте времени:
   - Подсвети конфликт с указанием что уже запланировано на это время
   - НЕ создавай событие автоматически при конфликте
   - Спроси пользователя что делать: перенести на другое время, отменить или оставить конфликт
7. Говори четко и указывай точное время в формате "суббота 10:00" или "среда 19:00" (всегда московское время).

ПРИМЕРЫ ПРАВИЛЬНЫХ ОТВЕТОВ:
✅ "Запомнил: секция у сына, суббота 10:00. Напомню в пятницу."
✅ "Сегодня спокойный день: секция в 10, уборка в 11."
✅ "Тут конфликт: на среду 19:00 уже запланировано 'встреча с девочками'. Что делаем: перенести на другое время или оставить конфликт?"
ПРИМЕРЫ НЕПРАВИЛЬНЫХ ОТВЕТОВ:
❌ "Задача создана. Статус: proposed. ID: 123"
❌ "Event scheduled for 2024-01-13T10:00:00Z"
❌ "Конфликт обнаружен. Переношу на 20:00." (не решай за пользователя, только спрашивай что делать)
❌ "Не могу понять" (всегда задавай уточняющие вопросы)""",
    tools=[
        check_availability,
        schedule_event,
        get_today_agenda,
    ],
    db=SqliteDb(db_file=DB_FILE),  # SQLite база данных для событий и истории диалогов
    add_history_to_context=True,
    markdown=True,
)
```

## 5. Настройка окружения для Cursor/Claude
1.  **Установка зависимостей:**
    ```bash
    pip install agno python-telegram-bot python-dotenv pydantic pytz
    ```
2.  **Переменные окружения (`.env`):**
    ```bash
    DEEPSEEK_API_KEY=your_deepseek_api_key  # API ключ DeepSeek
    TELEGRAM_BOT_TOKEN=your_telegram_bot_token
    DB_FILE=family_calendar.db  # Путь к SQLite базе данных (опционально)
    TIMEZONE=Europe/Moscow
    ```
2.  **Файл `.cursorrules`:** Положить в корень проекта для точных подсказок по синтаксису Agno.
    ```bash
    curl -o .cursorrules https://raw.githubusercontent.com/agno-agi/agno/main/.cursorrules
    ```
3.  **Структура проекта:**
    ```
    family-planner-agno/
    ├── .cursorrules
    ├── .env                    # Переменные: OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TIMEZONE
    ├── main.py                # Точка входа, конфигурация агента
    ├── core_logic/            # Изолированная бизнес-логика
    │   ├── __init__.py
    │   ├── calendar_tools.py  # Чистые функции: check_availability, schedule_event, get_today_agenda
    │   └── schemas.py         # Pydantic-модели: CalendarEvent, User, ParsedEvent...
    ├── agents_wrappers.py     # Обертки тулов для Agno (@agent.tool)
    ├── telegram_bot.py        # Логика Telegram-бота + уведомления партнера
    ├── scheduler.py           # Утренние дайджесты (cron/schedule)
    └── family_calendar.db     # SQLite база данных (создается автоматически)
    ```

## 6. Порядок реализации (Roadmap)

**Принцип разбиения:** Итерации структурированы так, чтобы можно было параллелить работу независимых агентов в Cursor. Каждая итерация — это отдельная, завершенная задача, которую можно реализовать независимо.

### Итерация 1: Базовая инфраструктура (MVP-0)
**Цель:** Создать минимально работающий бот, который принимает сообщения в Telegram и отвечает через агента (без тулов, просто базовый диалог).

**Задачи:**
*   Создать структуру проекта (папки, базовые файлы).
*   Настроить окружение (`.env`, зависимости).
*   Описать базовые Pydantic-модели (`schemas.py`): `User` (минимум: `telegram_id`, `name`, `partner_telegram_id`).
*   Создать схему БД (только таблица `users`).
*   Реализовать базовый Telegram-бот (`telegram_bot.py`):
    *   Подключение к Telegram API.
    *   Прием сообщений в личных чатах.
    *   Передача сообщения агенту.
    *   Отправка ответа пользователю.
*   Создать минимального агента (`main.py`):
    *   Конфигурация с DeepSeek моделью.
    *   Базовые инструкции (без тулов).
    *   Подключение к БД.
*   **Результат:** Бот работает, отвечает на сообщения, но не умеет планировать события.

**Критерий готовности:** Можно написать боту "Привет" и получить ответ.

---

### Итерация 2: Схема данных и модели
**Цель:** Подготовить все Pydantic-модели и схему БД для работы с событиями.

**Задачи:**
*   Описать все Pydantic-модели (`schemas.py`):
    *   `CalendarEvent`
    *   `ParsedEvent`
    *   `AvailabilityResult`
    *   `ScheduleResult`
    *   `ConflictInfo`
*   Расширить схему БД:
    *   Таблица `events` (все поля из раздела 2.4).
    *   Таблица `event_participants`.
    *   Индексы.
*   Создать миграции или ORM-модели для автоматического создания таблиц.

**Результат:** Все модели и схема БД готовы, но не используются в коде.

**Критерий готовности:** Можно запустить скрипт создания БД и получить все таблицы.

---

### Итерация 3: Работа с календарем (чтение)
**Цель:** Реализовать функции чтения календаря (проверка доступности, получение событий).

**Задачи:**
*   Реализовать `check_availability` (`core_logic/calendar_tools.py`):
    *   Проверка конфликтов в БД.
    *   Возврат списка конфликтующих событий.
*   Реализовать `get_today_agenda` (`core_logic/calendar_tools.py`):
    *   Получение событий на дату.
    *   Сортировка по времени.
*   Создать обертки тулов для Agno.
*   Добавить тулы в конфигурацию агента.

**Результат:** Агент может проверять доступность и получать список событий на день.

**Критерий готовности:** Можно спросить "что у нас сегодня?" и получить список событий.

---

### Итерация 4: Создание событий
**Цель:** Реализовать создание событий в календаре.

**Задачи:**
*   Реализовать `schedule_event` (`core_logic/calendar_tools.py`):
    *   Автоматическое определение участников (оба партнера).
    *   Проверка доступности через `check_availability`.
    *   Создание записи в БД.
    *   Обработка конфликтов (подсветка без автоматического решения).
*   Создать обертку тула для Agno.
*   Добавить тул в конфигурацию агента.
**Результат:** Агент может создавать события из естественного языка.

**Критерий готовности:** Можно написать "в субботу в 10 секция у сына" и событие создается в БД.

---

### Итерация 4: Уведомления партнера
**Цель:** Реализовать автоматические уведомления партнера о новых планах.

**Задачи:**
*   Реализовать `notify_partner_about_event` (`telegram_bot.py`):
    *   Поиск партнера по `partner_telegram_id`.
    *   Формирование сообщения в спокойном тоне.
    *   Отправка через Telegram API (не через агента).
    *   Установка флага `partner_notified`.
*   Интегрировать с `schedule_event` (вызов при успешном создании).

**Результат:** При создании события партнер автоматически получает уведомление.

**Критерий готовности:** При создании события вторым партнером приходит уведомление.

---

### Итерация 5: Утренние дайджесты
**Цель:** Реализовать автоматическую отправку утренних дайджестов.

**Задачи:**
*   Реализовать `scheduler.py`:
    *   Планировщик задач (cron или `schedule`).
    *   Для каждого пользователя отправка в его `digest_time`.
    *   Формирование сообщения на основе `get_today_agenda`.
    *   Отправка обоим партнерам.
*   Добавить поле `digest_time` в таблицу `users` (если еще не добавлено).

**Результат:** Каждое утро пользователи получают дайджест планов на день.

**Критерий готовности:** В настройное время приходит дайджест с планами.

---

### Итерация 6: Полировка и тестирование
**Цель:** Финальная доработка, обработка edge cases, тестирование.

**Задачи:**
*   Обработка всех edge cases (пустые сообщения, некорректные даты, и т.д.).
*   Улучшение формулировок ответов агента.
*   Тестирование всех сценариев из раздела 7.
*   Оптимизация производительности.

**Результат:** Полностью рабочий MVP, готовый к использованию.

**Критерий готовности:** Все критерии из раздела 7 выполнены.

## 7. Критерии успеха MVP

**Технические (30 мин тест):**
*   ✅ Понимает "в субботу в 10 секция" → напрямую создает событие через schedule_event
*   ✅ Второй получает уведомление о планах первого (автоматически)
*   ✅ Утренний дайджест приходит обоим в настраиваемое время (по умолчанию 07:00)
*   ✅ Конфликт по времени подсвечивается (но не решается автоматически)
*   ✅ Тон приятный, человеческий (без менеджерских терминов)

**С пользователями (после 2 дней):**
*   ✅ "Это реально упрощает жизнь"
*   ✅ Нет ощущения "ещё одна система"

## 8. Границы MVP (НЕ делать)

*   ❌ Статусы задач (todo/in_progress/done) - только "предложено"/"подтверждено"
*   ❌ Приоритеты/канбан
*   ❌ Финансы/проекты (кроме простых дедлайнов)
*   ❌ Интеграции (Google Calendar) - только после MVP
*   ❌ Веб‑UI/сложная аналитика
*   ❌ Автоматическое разрешение конфликтов (только подсветка)

## 9. Принятые решения

1.  **Конфликты времени:** Подсветка конфликта (но не автоматическое создание). Бот спрашивает что делать, пользователь решает.

2.  **Утренний дайджест:** Настраиваемое время для каждого пользователя (поле `users.digest_time`, по умолчанию 07:00).

3.  **Часовой пояс:** Всегда используется `Europe/Moscow` для всех операций.

4.  **События с несколькими участниками:** Автоматически для всех событий добавлять обоих партнеров (семейный календарь по умолчанию).

5.  **База данных:** Используется SQLite база данных для хранения событий календаря и истории диалогов агента. Agno создает свою таблицу сессий, наши таблицы хранят данные календаря.

6.  **Понимание естественного языка:** Агент напрямую понимает планы пользователя и вызывает инструменты с нужными параметрами. При неопределенности задает уточняющие вопросы.

---
**Ссылка на документацию Agno для справки:** [Agno Documentation](https://github.com/agno-agi/agno)

Это ТЗ можно напрямую копировать в Cursor или Claude Code, используя `.cursorrules` для контекстно-точных подсказок по коду.
