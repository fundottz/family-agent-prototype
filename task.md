# ТЗ: Семейный ИИ-планировщик на Agno

## 1. Общее описание
**Цель:** Создать ИИ-ассистента (бота) для координации семейных дел, согласования расписания и автоматического планирования через мессенджер (Telegram).

**Ключевая ценность:** "Невидимый семейный помощник", который берёт на себя рутину планирования, но **НЕ превращает дом в JIRA**. Меньше "а ты не забыла?", меньше конфликтов "почему ты не сказала?", больше спокойствия.

**Ключевые принципы:**
*   **Framework-agnostic:** Бизнес-логика (тулы) должна быть изолирована в чистых Python-функциях для максимальной переносимости между фреймворками.
*   **Self-hosted/Бесплатно:** Развертывание на собственном сервере или бесплатном cloud-хостинге.
*   **Прототипирование для CTO:** Код должен быть понятным, модульным и быстро адаптируемым для проверки гипотез.
*   **Естественный язык:** Пользователи пишут планы нативным языком ("в субботу в 10 секция у сына"), бот разбирает и структурирует.
*   **Тон общения:** Спокойный, разговорный, без менеджерских терминов. НЕ "Задача создана. Статус: proposed. ID: 123", а "Запомнил: секция сына, суббота 10:00."

## 2. Архитектурные требования

### 2.1. Фреймворк и структура
*   **Основной фреймворк:** Agno.
*   **Язык:** Python 3.11+.
*   **Архитектура:** Модульная. Чистая бизнес-логика отделена от оберток фреймворка.
*   **Стиль:** Асинхронный (использование `async/await`).
*   **LLM модель:** DeepSeek 

### 2.2. Модель взаимодействия
*   **Один бот** → **два личных чата** (муж↔бот, жена↔бот).
*   Каждый пользователь общается с ботом в своем личном чате.
*   Бот автоматически уведомляет партнера о новых планах (см. раздел 3.3).

### 2.3. Данные и состояние
*   **Хранение расписания:** Использовать встроенный `SqliteDb` от Agno или внешнюю SQLite/БД для хранения событий, пользователей и истории.
*   **Структуры данных:** Все входные/выходные данные тулов и сообщения описывать через **Pydantic-модели** (например, `CalendarEvent`, `User`, `TimeSlot`).
*   **Память агента:** Включить долгосрочную память (`add_history_to_context=True`) для сохранения контекста диалога.
*   **Часовой пояс:** Всегда используется `Europe/Moscow` для всех операций с датой и временем.

### 2.4. Структура базы данных (SQLite)

**Таблица: `events`**
| Поле | Тип | Описание |
|------|-----|----------|
| `id` | INTEGER PRIMARY KEY | Уникальный ID события |
| `title` | TEXT | Заголовок события ("секция у сына") |
| `datetime` | DATETIME | Дата и время события (UTC, хранить с timezone) |
| `duration_minutes` | INTEGER | Продолжительность в минутах |
| `creator_telegram_id` | INTEGER | Telegram ID создателя |
| `status` | TEXT | "предложено" / "подтверждено" (enum) |
| `category` | TEXT | "дети" / "дом" / "ремонт" / "личное" (enum) |
| `created_at` | DATETIME | Время создания записи |
| `partner_notified` | BOOLEAN | Флаг уведомления партнера (default: False) |

**Таблица: `users`**
| Поле | Тип | Описание |
|------|-----|----------|
| `id` | INTEGER PRIMARY KEY | Уникальный ID пользователя |
| `telegram_id` | INTEGER UNIQUE | Telegram ID пользователя |
| `name` | TEXT | Имя для обращения |
| `partner_telegram_id` | INTEGER | Telegram ID партнера (nullable) |
| `digest_time` | TEXT | Время отправки утреннего дайджеста (формат "HH:MM", default: "07:00") |

**Таблица: `event_participants`** (для событий с несколькими участниками)
| Поле | Тип | Описание |
|------|-----|----------|
| `id` | INTEGER PRIMARY KEY | Уникальный ID связи |
| `event_id` | INTEGER | FK к events.id |
| `user_id` | INTEGER | FK к users.id |
| `created_at` | DATETIME | Время создания связи |

**Индексы:**
*   `events(datetime, creator_telegram_id)` - для быстрого поиска по дате и пользователю
*   `users(telegram_id)` - для быстрого поиска пользователя
*   `event_participants(event_id, user_id)` - для поиска участников события

## 3. Функциональные требования (Тулы / Инструменты)
Каждый тул — это асинхронная Python-функция с аннотацией типов.

### 3.1. Основные инструменты

1.  **`parse_natural_language_event`** (КРИТИЧНО для MVP)
    *   **Вход:** `text: str`, `user_telegram_id: int`, `timezone: str = "Europe/Moscow"`
    *   **Выход:** `ParsedEvent` (Pydantic модель с полями: `title`, `datetime`, `category`, `duration_minutes`, `confidence: float`)
    *   **Логика:** 
        *   Использует LLM для парсинга естественного языка в структурированные данные.
        *   Распознает дату и время ("в субботу в 10", "среда 19:00", "завтра в 15:30").
        *   Определяет заголовок события и категорию автоматически.
        *   **Продолжительность:** LLM оценивает `duration_minutes` на основе контекста события (секция у сына → ~60 мин, встреча с друзьями → ~120 мин, уборка → ~60 мин). Если уверенность низкая (`confidence < 0.7`), агент должен уточнить у пользователя правильность определения длительности.
        *   Возвращает `None` если не удалось распарсить (агент должен спросить уточняющие вопросы).
    *   **Примеры:**
        *   "в субботу в 10 секция у сына" → `{"title": "секция у сына", "datetime": "2024-01-13T10:00:00+03:00", "category": "дети", "duration_minutes": 60, "confidence": 0.9}`
        *   "в среду в 19 встреча с девочками" → `{"title": "встреча с девочками", "datetime": "2024-01-10T19:00:00+03:00", "category": "личное", "duration_minutes": 120, "confidence": 0.85}`

2.  **`check_availability`**
    *   **Вход:** `user_id: int`, `start_time: datetime`, `duration_minutes: int`
    *   **Выход:** `AvailabilityResult` (Pydantic модель: `is_available: bool`, `conflicting_events: List[CalendarEvent]`)
    *   **Логика:** Проверяет в БД наличие событий у пользователя на заданный слот. Возвращает список конфликтующих событий если есть.

3.  **`schedule_event`**
    *   **Вход:** `event: CalendarEvent` (Pydantic модель), `creator_telegram_id: int`, `notify_partner: bool = True`
    *   **Выход:** `ScheduleResult` (Pydantic модель: `success: bool`, `event_id: int`, `conflicts: List[ConflictInfo]`, `alternative_slots: List[datetime]`, `message: str`)
    *   **Логика:**
        *   **Автоматически определяет участников:** Находит партнера создателя по `users.partner_telegram_id` и добавляет обоих партнеров в `user_ids` (семейный календарь по умолчанию).
        *   Для каждого `user_id` вызывает `check_availability`.
        *   Если все свободны — создает запись о событии в БД для всех участников (оба партнера).
        *   Если есть конфликт:
            *   **НЕ создает событие**, возвращает информацию о конфликте.
            *   **Автоматически ищет альтернативы:** Вызывает `find_common_slot` для поиска ближайших свободных слотов.
            *   Возвращает список альтернативных слотов в `alternative_slots`.
            *   **Важно:** Бот **НЕ решает конфликты автоматически**, только подсвечивает их и предлагает альтернативы. Пользователь сам решает что делать.
        *   Если `notify_partner=True` и событие создано успешно — вызывает `notify_partner_about_event`.

4.  **`find_common_slot`** (Ключевая логика)
    *   **Вход:** `user_ids: List[int]`, `duration_minutes: int`, `search_range_hours: int = 48`, `preferred_time: Optional[datetime] = None`
    *   **Выход:** `Optional[datetime]` (найденный слот) или `None`.
    *   **Логика:** Алгоритм поиска первого общего свободного окна в расписаниях всех указанных пользователей в пределах диапазона. Если `preferred_time` указан, ищет ближайший слот к предпочтительному времени.

5.  **`get_today_agenda`** (для утренних дайджестов)
    *   **Вход:** `user_ids: List[int]`, `date: Optional[date] = None` (default: сегодня)
    *   **Выход:** `List[CalendarEvent]`
    *   **Логика:** Возвращает список запланированных событий на указанную дату для группы пользователей, отсортированный по времени.

6.  **`notify_partner_about_event`** (КРИТИЧНО для MVP)
    *   **Вход:** `event: CalendarEvent`, `creator_telegram_id: int`
    *   **Выход:** `bool` (успешно отправлено/нет)
    *   **Логика:**
        *   Находит партнера создателя по `users.partner_telegram_id`.
        *   Формирует сообщение в спокойном тоне: "Жена заняла субботу 10:00: секция у сына" или "Муж занял субботу 11:00: поехать за продуктами".
        *   Отправляет сообщение партнеру через Telegram API (не через агента, чтобы избежать рекурсии).
        *   Устанавливает флаг `partner_notified=True` в БД.

### 3.2. Автоматические задачи (фоновые)

1.  **Утренний дайджест** (КРИТИЧНО для MVP)
    *   **Триггер:** Ежедневно для каждого пользователя в его настраиваемое время (`users.digest_time`, по умолчанию 07:00) через `schedule` или cron.
    *   **Логика:**
        *   Для каждого пользователя с настроенным `digest_time` вызывает `get_today_agenda` с его `telegram_id` и `partner_telegram_id`.
        *   Формирует сообщение в спокойном тоне (см. примеры ниже).
        *   Отправляет одинаковый дайджест обоим партнерам (если у них разное время дайджеста, каждый получит в свое время).
    *   **Примеры сообщений:**
        *   Спокойный день: "Доброе утро! Сегодня спокойный день:\n- 10:00 — секция у сына\n- 11:00 — поехать за продуктами"
        *   Насыщенный день: "Доброе утро! Сегодня много дел:\n- 09:00 — уборка\n- 10:00 — секция у сына\n- 12:00 — обед с родителями"
        *   Свободный день: "Доброе утро! На сегодня планов нет. Отдыхайте!"

### 3.3. Интеграция с мессенджером
*   **Канал:** Telegram.
*   **Реализация:** Отдельный модуль (`telegram_bot.py`), который:
    *   Запускает бота через `python-telegram-bot` или `aiogram`.
    *   Принимает сообщения в личных чатах.
    *   Передает сообщение агенту `family_planner.run()` для обработки.
    *   Отправляет ответ пользователю.
    *   **Важно:** Обрабатывает команды типа "что у нас сегодня?" → вызывает `get_today_agenda` и форматирует ответ.

## 4. Агент и его конфигурация

### 4.1. Системный промпт для парсинга естественного языка
```python
PARSE_EVENT_PROMPT = """Ты - помощник для парсинга семейных планов из естественного языка.

Твоя задача:
1. Извлекать из текста информацию о событии
2. Распознавать дату и время ("в субботу в 10", "среда 19:00", "завтра в 15:30") - всегда используй часовой пояс Europe/Moscow (+03:00)
3. Определять заголовок события
4. Определять категорию: "дети" / "дом" / "ремонт" / "личное"
5. Оценивать продолжительность на основе контекста:
   - Секции/занятия детей: обычно 60-90 минут
   - Встречи с друзьями: обычно 120-180 минут
   - Уборка/домашние дела: обычно 60-120 минут
   - Ремонт/мастер: зависит от контекста (30-240 минут)
   - Личные дела: обычно 60-120 минут
6. Оценивать уверенность (confidence) в правильности определения продолжительности (0.0-1.0)
7. Возвращать JSON: { "title": "...", "datetime": "ISO 8601 с timezone +03:00", "category": "...", "duration_minutes": 60, "confidence": 0.9 }

Примеры:
- "в субботу в 10 секция у сына" → {"title": "секция у сына", "datetime": "2024-01-13T10:00:00+03:00", "category": "дети", "duration_minutes": 60, "confidence": 0.9}
- "в среду в 19 встреча с девочками" → {"title": "встреча с девочками", "datetime": "2024-01-10T19:00:00+03:00", "category": "личное", "duration_minutes": 120, "confidence": 0.85}
- "завтра в 15:30 уборка" → {"title": "уборка", "datetime": "2024-01-09T15:30:00+03:00", "category": "дом", "duration_minutes": 90, "confidence": 0.7}

Если не можешь определить дату/время - верни null для datetime.
Если уверенность в продолжительности низкая (confidence < 0.7) - укажи это в confidence.
Возвращай только JSON, без дополнительного текста."""
```

### 4.2. Конфигурация агента
```python
# Конфигурация агента в main.py
family_planner = Agent(
    name="Family Planner",
    model=OpenAIChat(id="deepseek-chat", base_url="https://api.deepseek.com"), # DeepSeek модель
    instructions="""Ты вежливый координатор для семьи. Твоя задача — помогать планировать дела, находить пересечения в расписаниях и разрешать конфликты.

КЛЮЧЕВЫЕ ПРИНЦИПЫ:
1. Говори спокойно, разговорно, без менеджерских терминов. НЕ используй слова "задача", "статус", "ID", "дедлайн".
2. Всегда используй инструмент parse_natural_language_event для понимания планов пользователя.
3. Если parse_natural_language_event вернул None или confidence < 0.7 - спроси уточняющие вопросы у пользователя (например: "Во сколько примерно продлится секция?" или "Не понял дату, уточни пожалуйста").
4. Все события автоматически добавляются в общий семейный календарь (оба партнера участвуют).
5. Всегда используй инструменты для проверки календаря перед планированием.
6. При конфликте времени:
   - Подсвети конфликт с указанием кто и что уже запланировал
   - Автоматически найди альтернативные свободные слоты через find_common_slot
   - Предложи альтернативы пользователю, но НЕ создавай событие автоматически
   - Спроси пользователя что делать: перенести, отменить или оставить конфликт
7. Говори четко и указывай точное время в формате "суббота 10:00" или "среда 19:00" (всегда московское время).

ПРИМЕРЫ ПРАВИЛЬНЫХ ОТВЕТОВ:
✅ "Запомнил: секция у сына, суббота 10:00. Напомню в пятницу."
✅ "Сегодня спокойный день: секция в 10, уборка в 11."
✅ "Тут конфликт с планом жены на среду 19:00 (встреча с девочками). Могу предложить альтернативы: среда 18:00 или четверг 19:00. Что делаем?"
✅ "Я определил продолжительность секции как 60 минут. Это правильно?"

ПРИМЕРЫ НЕПРАВИЛЬНЫХ ОТВЕТОВ:
❌ "Задача создана. Статус: proposed. ID: 123"
❌ "Event scheduled for 2024-01-13T10:00:00Z"
❌ "Конфликт обнаружен. Переношу на 20:00." (не решай за пользователя, только предлагай)
❌ "Не могу распарсить" (всегда задавай уточняющие вопросы)""",
    tools=[
        parse_natural_language_event,
        check_availability,
        schedule_event,
        find_common_slot,
        get_today_agenda,
    ],
    db=SqliteDb(db_file="family_calendar.db"),
    add_history_to_context=True,
    markdown=True,
)
```

## 5. Настройка окружения для Cursor/Claude
1.  **Установка зависимостей:**
    ```bash
    pip install agno python-telegram-bot python-dotenv pydantic pytz
    ```
2.  **Переменные окружения (`.env`):**
    ```bash
    OPENAI_API_KEY=your_deepseek_api_key  # API ключ DeepSeek
    TELEGRAM_BOT_TOKEN=your_telegram_bot_token
    TIMEZONE=Europe/Moscow
    ```
2.  **Файл `.cursorrules`:** Положить в корень проекта для точных подсказок по синтаксису Agno.
    ```bash
    curl -o .cursorrules https://raw.githubusercontent.com/agno-agi/agno/main/.cursorrules
    ```
3.  **Структура проекта:**
    ```
    family-planner-agno/
    ├── .cursorrules
    ├── .env                    # Переменные: OPENAI_API_KEY, TELEGRAM_BOT_TOKEN, TIMEZONE
    ├── main.py                # Точка входа, конфигурация агента
    ├── core_logic/            # Изолированная бизнес-логика
    │   ├── __init__.py
    │   ├── calendar_tools.py  # Чистые функции: check_availability, find_common_slot
    │   ├── parsing.py         # Парсинг естественного языка (parse_natural_language_event)
    │   └── schemas.py         # Pydantic-модели: CalendarEvent, User, ParsedEvent...
    ├── agents_wrappers.py     # Обертки тулов для Agno (@agent.tool)
    ├── telegram_bot.py        # Логика Telegram-бота + уведомления партнера
    ├── scheduler.py           # Утренние дайджесты (cron/schedule)
    └── family_calendar.db     # SQLite база (создастся автоматически)
    ```

## 6. Порядок реализации (Roadmap)

**Принцип разбиения:** Итерации структурированы так, чтобы можно было параллелить работу независимых агентов в Cursor. Каждая итерация — это отдельная, завершенная задача, которую можно реализовать независимо.

### Итерация 1: Базовая инфраструктура (MVP-0)
**Цель:** Создать минимально работающий бот, который принимает сообщения в Telegram и отвечает через агента (без тулов, просто базовый диалог).

**Задачи:**
*   Создать структуру проекта (папки, базовые файлы).
*   Настроить окружение (`.env`, зависимости).
*   Описать базовые Pydantic-модели (`schemas.py`): `User` (минимум: `telegram_id`, `name`, `partner_telegram_id`).
*   Создать схему БД (только таблица `users`).
*   Реализовать базовый Telegram-бот (`telegram_bot.py`):
    *   Подключение к Telegram API.
    *   Прием сообщений в личных чатах.
    *   Передача сообщения агенту.
    *   Отправка ответа пользователю.
*   Создать минимального агента (`main.py`):
    *   Конфигурация с DeepSeek моделью.
    *   Базовые инструкции (без тулов).
    *   Подключение к БД.
*   **Результат:** Бот работает, отвечает на сообщения, но не умеет планировать события.

**Критерий готовности:** Можно написать боту "Привет" и получить ответ.

---

### Итерация 2: Схема данных и модели
**Цель:** Подготовить все Pydantic-модели и схему БД для работы с событиями.

**Задачи:**
*   Описать все Pydantic-модели (`schemas.py`):
    *   `CalendarEvent`
    *   `ParsedEvent`
    *   `AvailabilityResult`
    *   `ScheduleResult`
    *   `ConflictInfo`
*   Расширить схему БД:
    *   Таблица `events` (все поля из раздела 2.4).
    *   Таблица `event_participants`.
    *   Индексы.
*   Создать миграции или ORM-модели для автоматического создания таблиц.

**Результат:** Все модели и схема БД готовы, но не используются в коде.

**Критерий готовности:** Можно запустить скрипт создания БД и получить все таблицы.

---

### Итерация 3: Парсинг естественного языка
**Цель:** Реализовать парсинг планов из естественного языка.

**Задачи:**
*   Реализовать `parse_natural_language_event` (`core_logic/parsing.py`):
    *   Использование LLM (DeepSeek) для парсинга.
    *   Системный промпт из раздела 4.1.
    *   Обработка ошибок парсинга.
*   Создать обертку тула для Agno (`agents_wrappers.py`).
*   Добавить тул в конфигурацию агента.
*   Обновить инструкции агента для использования парсинга.

**Результат:** Агент может понимать "в субботу в 10 секция у сына" и парсить в структурированные данные.

**Критерий готовности:** Агент корректно парсит тестовые фразы и возвращает `ParsedEvent`.

---

### Итерация 4: Работа с календарем (чтение)
**Цель:** Реализовать функции чтения календаря (проверка доступности, получение событий).

**Задачи:**
*   Реализовать `check_availability` (`core_logic/calendar_tools.py`):
    *   Проверка конфликтов в БД.
    *   Возврат списка конфликтующих событий.
*   Реализовать `get_today_agenda` (`core_logic/calendar_tools.py`):
    *   Получение событий на дату.
    *   Сортировка по времени.
*   Создать обертки тулов для Agno.
*   Добавить тулы в конфигурацию агента.

**Результат:** Агент может проверять доступность и получать список событий на день.

**Критерий готовности:** Можно спросить "что у нас сегодня?" и получить список событий.

---

### Итерация 5: Создание событий
**Цель:** Реализовать создание событий в календаре.

**Задачи:**
*   Реализовать `schedule_event` (`core_logic/calendar_tools.py`):
    *   Автоматическое определение участников (оба партнера).
    *   Проверка доступности через `check_availability`.
    *   Создание записи в БД.
    *   Обработка конфликтов (пока без альтернатив).
*   Создать обертку тула для Agno.
*   Добавить тул в конфигурацию агента.
*   Интегрировать с `parse_natural_language_event`.

**Результат:** Агент может создавать события из естественного языка.

**Критерий готовности:** Можно написать "в субботу в 10 секция у сына" и событие создается в БД.

---

### Итерация 6: Уведомления партнера
**Цель:** Реализовать автоматические уведомления партнера о новых планах.

**Задачи:**
*   Реализовать `notify_partner_about_event` (`telegram_bot.py`):
    *   Поиск партнера по `partner_telegram_id`.
    *   Формирование сообщения в спокойном тоне.
    *   Отправка через Telegram API (не через агента).
    *   Установка флага `partner_notified`.
*   Интегрировать с `schedule_event` (вызов при успешном создании).

**Результат:** При создании события партнер автоматически получает уведомление.

**Критерий готовности:** При создании события вторым партнером приходит уведомление.

---

### Итерация 7: Поиск альтернативных слотов
**Цель:** Реализовать поиск свободных слотов и предложение альтернатив при конфликтах.

**Задачи:**
*   Реализовать `find_common_slot` (`core_logic/calendar_tools.py`):
    *   Алгоритм поиска свободных окон.
    *   Учет предпочтительного времени.
    *   Поиск в заданном диапазоне.
*   Обновить `schedule_event`:
    *   При конфликте автоматически искать альтернативы.
    *   Возвращать список альтернативных слотов.
*   Обновить инструкции агента для предложения альтернатив.

**Результат:** При конфликте агент предлагает альтернативные свободные слоты.

**Критерий готовности:** При конфликте агент предлагает варианты переноса.

---

### Итерация 8: Утренние дайджесты
**Цель:** Реализовать автоматическую отправку утренних дайджестов.

**Задачи:**
*   Реализовать `scheduler.py`:
    *   Планировщик задач (cron или `schedule`).
    *   Для каждого пользователя отправка в его `digest_time`.
    *   Формирование сообщения на основе `get_today_agenda`.
    *   Отправка обоим партнерам.
*   Добавить поле `digest_time` в таблицу `users` (если еще не добавлено).

**Результат:** Каждое утро пользователи получают дайджест планов на день.

**Критерий готовности:** В настройное время приходит дайджест с планами.

---

### Итерация 9: Уточнение продолжительности
**Цель:** Добавить уточнение продолжительности событий при низкой уверенности LLM.

**Задачи:**
*   Обновить `parse_natural_language_event`:
    *   Возврат `confidence` в результате.
    *   Обработка низкой уверенности.
*   Обновить инструкции агента:
    *   При `confidence < 0.7` задавать уточняющие вопросы.
    *   Примеры правильных вопросов.

**Результат:** При неопределенности продолжительности агент уточняет у пользователя.

**Критерий готовности:** При низкой уверенности агент спрашивает "Это правильно?".

---

### Итерация 10: Полировка и тестирование
**Цель:** Финальная доработка, обработка edge cases, тестирование.

**Задачи:**
*   Обработка всех edge cases (пустые сообщения, некорректные даты, и т.д.).
*   Улучшение формулировок ответов агента.
*   Тестирование всех сценариев из раздела 7.
*   Оптимизация производительности.

**Результат:** Полностью рабочий MVP, готовый к использованию.

**Критерий готовности:** Все критерии из раздела 7 выполнены.

## 7. Критерии успеха MVP

**Технические (30 мин тест):**
*   ✅ Понимает "в субботу в 10 секция" → корректно парсит и создает событие
*   ✅ Второй получает уведомление о планах первого (автоматически)
*   ✅ Утренний дайджест приходит обоим в настраиваемое время (по умолчанию 07:00)
*   ✅ Конфликт по времени подсвечивается с предложением альтернатив (но не решается автоматически)
*   ✅ Тон приятный, человеческий (без менеджерских терминов)

**С пользователями (после 2 дней):**
*   ✅ "Это реально упрощает жизнь"
*   ✅ Нет ощущения "ещё одна система"

## 8. Границы MVP (НЕ делать)

*   ❌ Статусы задач (todo/in_progress/done) - только "предложено"/"подтверждено"
*   ❌ Приоритеты/канбан
*   ❌ Финансы/проекты (кроме простых дедлайнов)
*   ❌ Интеграции (Google Calendar) - только после MVP
*   ❌ Веб‑UI/сложная аналитика
*   ❌ Автоматическое разрешение конфликтов (только подсветка)

## 9. Принятые решения

1.  **Конфликты времени:** Подсветка + предложение альтернатив через `find_common_slot` (но не автоматическое создание). Бот предлагает варианты, пользователь решает.

2.  **Продолжительность событий:** LLM оценивает на основе контекста. Если уверенность низкая (`confidence < 0.7`), агент уточняет у пользователя правильность определения длительности.

3.  **Утренний дайджест:** Настраиваемое время для каждого пользователя (поле `users.digest_time`, по умолчанию 07:00).

4.  **Часовой пояс:** Всегда используется `Europe/Moscow` для всех операций.

5.  **События с несколькими участниками:** Автоматически для всех событий добавлять обоих партнеров (семейный календарь по умолчанию).

6.  **Обработка ошибок парсинга:** Агент задает уточняющие вопросы если `parse_natural_language_event` вернул `None` или низкую уверенность.

---
**Ссылка на документацию Agno для справки:** [Agno Documentation](https://github.com/agno-agi/agno)

Это ТЗ можно напрямую копировать в Cursor или Claude Code, используя `.cursorrules` для контекстно-точных подсказок по коду.
