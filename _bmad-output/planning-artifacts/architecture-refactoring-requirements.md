# Требования: Рефакторинг архитектуры агента на Intent-based систему

**Дата:** 2026-01-09  
**Автор:** Andrey  
**Статус:** Требуется реализация

---

## Проблема текущей архитектуры

**Текущее состояние:**
- Агент использует набор низкоуровневых инструментов (tools)
- LLM сам планирует последовательность вызовов инструментов
- Логика описана в промпте через инструкции

**Проблемы:**
1. Нестабильность: LLM может вызвать инструменты в неправильном порядке или пропустить шаги
2. Медленность: множественные последовательные вызовы LLM → инструмент → LLM → инструмент
3. Сложность расширения: добавление новой фичи требует изменения промпта
4. Сложность отладки: логика размазана между промптом и кодом инструментов

---

## Целевая архитектура

**Принцип:** LLM как классификатор Intent'ов + детерминированные макрокоманды

**Суть:**
- LLM только распознаёт Intent и заполняет параметры (один вызов)
- Вся сложная логика инкапсулирована внутри макрокоманд
- Каждая макрокоманда знает свой полный сценарий от начала до конца

**Преимущества:**
- Стабильность: логика в коде, а не в промпте
- Скорость: один вызов LLM для классификации, затем детерминированное выполнение
- Расширяемость: новая фича = новая макрокоманда
- Отладка: логика локализована в макрокомандах
- Тестируемость: макрокоманды можно тестировать изолированно

---

## Intent'ы (6 штук)

### 1. CreateEventIntent
**Описание:** Создать новое событие с проверкой конфликтов  
**Параметры:**
- title: str
- datetime: datetime
- duration_minutes: int
- category: EventCategory
- participant_scope: str ('self' | 'both')

**Логика макрокоманды:**
1. Проверить конфликты через `check_availability`
2. Если конфликт → вернуть информацию о конфликте
3. Если свободно → создать событие через `schedule_event`
4. Уведомить партнёра (если нужно)

---

### 2. UpdateEventIntent
**Описание:** Изменить существующее событие  
**Параметры:**
- event_id: int
- updates: dict (title, datetime, duration_minutes, category)

**Логика макрокоманды:**
1. Получить событие по ID
2. Проверить права (только создатель может изменять)
3. Если изменяется время → проверить конфликты
4. Обновить событие через `update_event`
5. Уведомить партнёра об изменениях

---

### 3. CancelEventIntent
**Описание:** Отменить событие(я)  
**Параметры:**
- event_ids: List[int] (опционально)
- start_date: date (опционально)
- end_date: date (опционально)
- category: EventCategory (опционально)
- title_pattern: str (опционально)

**Логика макрокоманды:**
1. Найти события для отмены через `find_events_to_cancel`
2. Отменить через `cancel_events`
3. Уведомить партнёра об отмене

---

### 4. ProposeEventIntent
**Описание:** Предложить новое событие на согласование  
**Параметры:**
- title: str
- datetime: datetime
- duration_minutes: int
- category: EventCategory
- participant_scope: str

**Логика макрокоманды:**
1. Проверить конфликты
2. Создать событие со статусом "предложено"
3. Отправить запрос на согласование партнёру (с кнопками)
4. Сохранить event_id для callback

---

### 5. HandleProposalIntent
**Описание:** Согласовать/отклонить/предложить изменение предложения  
**Параметры:**
- event_id: int
- action: str ('approve' | 'reject' | 'suggest_change')
- suggested_changes: dict (опционально, если action='suggest_change')

**Логика макрокоманды:**
1. Получить событие по ID
2. Проверить права (только партнёр создателя может согласовывать)
3. В зависимости от action:
   - approve → обновить статус на "подтверждено", уведомить создателя
   - reject → удалить событие, уведомить создателя
   - suggest_change → отправить предложение изменений создателю

---

### 6. GetAgendaIntent
**Описание:** Получить адженду за произвольный период  
**Параметры:**
- start_date: date
- end_date: date (опционально, по умолчанию = start_date)

**Логика макрокоманды:**
1. Получить события через `get_events_in_range`
2. Отсортировать по времени
3. Отформатировать для пользователя

---

## Структура кода

```
intent_classifier.py      # Классификация Intent'ов
macro_commands/
  ├── __init__.py
  ├── base.py            # Базовый класс MacroCommand
  ├── create_event.py     # CreateEventMacroCommand
  ├── update_event.py    # UpdateEventMacroCommand
  ├── cancel_event.py    # CancelEventMacroCommand
  ├── propose_event.py   # ProposeEventMacroCommand
  ├── handle_proposal.py # HandleProposalMacroCommand
  └── get_agenda.py      # GetAgendaMacroCommand
```

---

## Этапы реализации

### Этап 1: Intent-классификатор (4-6 часов)
- Модуль `intent_classifier.py`
- LLM определяет Intent + параметры за один вызов
- Pydantic-модели для каждого Intent'а

### Этап 2: Макрокоманды (8-12 часов)
- Базовый класс `MacroCommand`
- 6 макрокоманд с полной логикой

### Этап 3: Интеграция (4-6 часов)
- Новый агент с Intent-based архитектурой
- Интеграция классификатора и макрокоманд
- Тесты

### Этап 4: Миграция (2-4 часа)
- Замена старого агента на новый
- Удаление старого кода

**Общая оценка:** 18-28 часов (2.5-3.5 рабочих дня)

---

## Критерии успеха

- ✅ Один вызов LLM для классификации Intent'а
- ✅ Детерминированное выполнение макрокоманды
- ✅ Все 6 Intent'ов работают
- ✅ Тесты покрывают все сценарии
- ✅ Производительность улучшена (меньше вызовов LLM)

---

## Зависимости

- Существующие инструменты из `core_logic/calendar_tools.py`
- Существующие схемы из `core_logic/schemas.py`
- Существующая БД из `core_logic/database.py`

---

## Риски и митигации

**Риск:** Неправильная классификация Intent'ов  
**Митигация:** Fallback на старую систему для неопределённых случаев

**Риск:** Сложность миграции  
**Митигация:** Поэтапная миграция, сохранение старой системы параллельно

---

## Примечания

- Старая архитектура должна быть сохранена до полной миграции
- Тесты должны покрывать все Intent'ы и edge cases
- Документация должна описывать новую архитектуру
